<!--
Сверстать статью использовав:
+1. Теги p, h1, h2, br, span.
+2. Ссылку на внешний ресурс.
+3. Несколько изображений разных размеров.
+4. Задать любому тегу любые стили через class, id, inline-style.
+5. Задать title для страницы.
+6. Собрать таблицу.
+7. Сверстать форму для регистрации, использовав разные типы input + select.
+8. Использовать внешние и внутренние отступы.
+9. Задать размеры для текста используя разные единицы измерений.
+10. Использовать для текста все три вида задания цвета.
+11. Использовать псеводклассы и псевдоэлементы.
+12. Надстрочный текст.
+13. Подстрочный текст.
+14. Ограничить высоту и ширину некоторых блоков.
!-->



<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <title>Быстрая сортировка</title>
</head>

<body>
    <p><a href="reg.html">Регистрация</a> </p>
    <h1>
        <p><a href="https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">Оригинал статьи</a> </p>
    </h1>
    <h2><span id="id"><u>Быстрая сортировка</u></span></h2>
    <hr>
    <img src="images/1.gif" alt="гифка qsort">
    <table border="1px">
        <tr>
            <td>Автор</td>
            <td>Хоар, Чарлз Энтони Ричард</td>
        </tr>
        <tr>
            <td>Худшее время</td>
            <td>O<sub>(n<sup>2</sup>)</sub></td>
        </tr>
        <tr>
            <td>Лучшее время</td>
            <td>O(n log n) (обычное разделение) или O(n) (разделение на 3 части)</td>
        </tr>
        <tr>
            <td>Среднее время</td>
            <td>O(n log n)</td>
        </tr>
        <tr>
            <td>Затраты памяти</td>
            <td>O(n) вспомогательных O(log n) вспомогательных (Седжвик 1978)</td>
        </tr>
    </table>
    <div class="text">
        Быстрая сортировка, сортировка Хоара (англ. quicksort), часто называемая qsort (по имени в стандартной библиотеке языка Си) — алгоритм сортировки, разработанный английским информатиком Тони Хоаром во время его работы в МГУ в 1960 году.<br> <br>Один
        из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем {\displaystyle O(n\log n)}O(n\log n) обменов при упорядочении {\displaystyle n}n элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми
        доработками. Общее описание QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного в том числе своей низкой эффективностью.
        Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. (Таким образом улучшение самого неэффективного прямого
        метода сортировки дало в результате один из наиболее эффективных улучшенных методов.)
    </div>
    <h2><span><u>Общее описание</u></span></h2>
    <hr>
    <div class="text">
        QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного в том числе своей низкой эффективностью. Принципиальное отличие
        состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы. (Таким образом улучшение самого неэффективного прямого метода сортировки дало
        в результате один из наиболее эффективных улучшенных методов.)<br><br>Общая идея алгоритма состоит в следующем:<br>
        <p style="margin-left:70px">• Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см. ниже).</p>
        <p style="margin-left:70px">• Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».</p>
        <p style="margin-left:70px">• Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.</p><br> На практике массив обычно делят не на три, а на две части: например, «меньшие опорного» и «равные
        и большие»; такой подход в общем случае эффективнее, так как упрощает алгоритм разделения (см. ниже).<br><br> Хоар разработал этот метод применительно к машинному переводу; словарь хранился на магнитной ленте, и сортировка слов обрабатываемого
        текста позволяла получить их переводы за один прогон ленты, без перемотки её назад. Алгоритм был придуман Хоаром во время его пребывания в Советском Союзе, где он обучался в Московском университете компьютерному переводу и занимался разработкой
        русско-английского разговорника.
    </div>
    <h2><span><u>Алгоритм</u></span></h2>
    <hr>
    <img src="images/2.png" alt="пример qsort" style="margin-left:100px">
    <div class="text">
        <p>Общий механизм сортировки</p>Быстрая сортировка относится к алгоритмам «разделяй и властвуй».<br>Алгоритм состоит из трёх шагов:
        <p style="margin-left:70px">1.Выбрать элемент из массива. Назовём его опорным.</p>
        <p style="margin-left:70px">2.Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные после.</p>
        <p style="margin-left:70px">3.Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.</p><br><br> В наиболее общем виде алгоритм на псевдокоде
        (где A — сортируемый массив, а low и high — соответственно, нижняя и верхняя границы сортируемого участка этого массива) выглядит следующим образом:
        <div class="code"><pre> algorithm quicksort(A, low, high) is
            if low < high then
                p:= partition(A, low, high)
                quicksort(A, low, p - 1)
                quicksort(A, p + 1, high)</pre></div>
    </div>
    <h2><span><u>Оценка сложности алгоритма</u></span></h2>
    <hr>
    <div class="text">Ясно, что операция разделения массива на две части относительно опорного элемента занимает время {\displaystyle O(\log _{2}n)}{\displaystyle O(\log _{2}n)}. Поскольку все операции разделения, проделываемые на одной глубине рекурсии, обрабатывают разные
        части исходного массива, размер которого постоянен, суммарно на каждом уровне рекурсии потребуется также {\displaystyle O(n)}O(n) операций. Следовательно, общая сложность алгоритма определяется лишь количеством разделений, то есть глубиной рекурсии.
        Глубина рекурсии, в свою очередь, зависит от сочетания входных данных и способа определения опорного элемента.
        <h3>Лучший случай.</h3>
        <div class="text_level_1"> В наиболее сбалансированном варианте при каждой операции разделения массив делится на две одинаковые (плюс-минус один элемент) части, следовательно, максимальная глубина рекурсии, при которой размеры обрабатываемых подмассивов достигнут 1, составит
            {\displaystyle \log _{2}n}\log _{2}n. В результате количество сравнений, совершаемых быстрой сортировкой, было бы равно значению рекурсивного выражения {\displaystyle C_{n}=2\cdot C_{n/2}+n}C_{n}=2\cdot C_{{n/2}}+n, что даёт общую сложность
            алгоритма {\displaystyle O(n\cdot \log _{2}n)}O(n\cdot \log _{2}n).</div>

        <h3>Среднее.</h3>
        <div class="text_level_1">Среднюю сложность при случайном распределении входных данных можно оценить лишь вероятностно. Прежде всего необходимо заметить, что в действительности необязательно, чтобы опорный элемент всякий раз делил массив на две одинаковых части. Например,
            если на каждом этапе будет происходить разделение на массивы длиной 75 % и 25 % от исходного, глубина рекурсии будет равна {\displaystyle \log _{4/3}n}\log _{{4/3}}n, а это по-прежнему даёт сложность {\displaystyle O(n\log n)}O(n\log n). Вообще,
            при любом фиксированном соотношении между левой и правой частями разделения сложность алгоритма будет той же, только с разными константами. Будем считать «удачным» разделением такое, при котором опорный элемент окажется среди центральных 50
            % элементов разделяемой части массива; ясно, вероятность удачи при случайном распределении элементов составляет 0,5. При удачном разделении размеры выделенных подмассивов составят не менее 25 % и не более 75 % от исходного. Поскольку каждый
            выделенный подмассив также будет иметь случайное распределение, все эти рассуждения применимы к любому этапу сортировки и любому исходному фрагменту массива. Удачное разделение даёт глубину рекурсии не более {\displaystyle \log _{4/3}n}\log
            _{{4/3}}n. Поскольку вероятность удачи равна 0,5, для получения {\displaystyle k}k удачных разделений в среднем потребуется {\displaystyle 2\cdot k}2\cdot k рекурсивных вызовов, чтобы опорный элемент k раз оказался среди центральных 50 % массива.
            Применяя эти соображения, можно заключить, что в среднем глубина рекурсии не превысит {\displaystyle 2\cdot \log _{4/3}n}2\cdot \log _{{4/3}}n, что равно {\displaystyle O(\log n)}O(\log n) А поскольку на каждом уровне рекурсии по-прежнему
            выполняется не более {\displaystyle O(n)}O(n) операций, средняя сложность составит {\displaystyle O(n\log n)}O(n\log n).</div>
        <h3>Худший случай.</h3>
        <div class="text_level_1"> В самом несбалансированном варианте каждое разделение даёт два подмассива размерами 1 и {\displaystyle n-1}n-1, то есть при каждом рекурсивном вызове больший массив будет на 1 короче, чем в предыдущий раз. Такое может произойти, если в качестве
            опорного на каждом этапе будет выбран элемент либо наименьший, либо наибольший из всех обрабатываемых. При простейшем выборе опорного элемента — первого или последнего в массиве, — такой эффект даст уже отсортированный (в прямом или обратном
            порядке) массив, для среднего или любого другого фиксированного элемента «массив худшего случая» также может быть специально подобран. В этом случае потребуется {\displaystyle n-1}n-1 операций разделения, а общее время работы составит {\displaystyle
            \textstyle \sum _{i=0}^{n}(n-i)=O(n^{2})}\textstyle \sum _{{i=0}}^{n}(n-i)=O(n^{2}) операций, то есть сортировка будет выполняться за квадратичное время. Но количество обменов и, соответственно, время работы — это не самый большой его недостаток.
            Хуже то, что в таком случае глубина рекурсии при выполнении алгоритма достигнет n, что будет означать n-кратное сохранение адреса возврата и локальных переменных процедуры разделения массивов. Для больших значений n худший случай может привести
            к исчерпанию памяти (переполнению стека) во время работы программы.</div>

    </div>
    <h2><span><u>Достоинства и недостатки</u></span></h2>
    <hr>
    <div class="text">
        <h3>Достоинства:</h3>
        <div class="text_level_1">Один из самых быстродействующих (на практике) из алгоритмов внутренней сортировки общего назначения.<br> Алгоритм очень короткий: запомнив основные моменты, его легко написать «из головы», невелика константа при {\displaystyle n\log n}{\displaystyle
            n\log n}.<br> Требует лишь {\displaystyle O(\log n)}O(\log n) дополнительной памяти для своей работы. (Не улучшенный рекурсивный алгоритм в худшем случае {\displaystyle O(n)}O(n) памяти)<br> Хорошо сочетается с механизмами кэширования и виртуальной
            памяти.
            <br> Допускает естественное распараллеливание (сортировка выделенных подмассивов в параллельно выполняющихся подпроцессах).<br> Допускает эффективную модификацию для сортировки по нескольким ключам (в частности — алгоритм Седжвика для сортировки
            строк): благодаря тому, что в процессе разделения автоматически выделяется отрезок элементов, равных опорному, этот отрезок можно сразу же сортировать по следующему ключу.<br> Работает на связных списках и других структурах с последовательным
            доступом, допускающих эффективный проход как от начала к концу, так и от конца к началу.<br></div>
        <h3>Недостатки:</h3>
        <div class="text_level_1">Сильно деградирует по скорости (до {\displaystyle O(n^{2})}O(n^{2})) в худшем или близком к нему случае, что может случиться при неудачных входных данных.<br> Прямая реализация в виде функции с двумя рекурсивными вызовами может привести к ошибке
            переполнения стека, так как в худшем случае ей может потребоваться сделать {\displaystyle O(n)}O(n) вложенных рекурсивных вызовов.<br> Неустойчив.
            <br></div>

    </div>



</body>

</html>